using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Rhino.Geometry;

namespace Cells.src.Voxels
{
    public class ComputeShortestPathMain : GH_Component
    {
        public ComputeShortestPathMain()
          : base("Compute Shortest Path", "shortest path",
              "Shortest Path between points in a graph (voxel Grid)",
              "Cells", "Voxels")
        {
        }
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            List<int> input = new List<int> { 0, 0, 0 };
            List<int> output = new List<int> { 1, 1, 1 };
            // 0. voxel grid
            pManager.AddGenericParameter("input voxel grid", "voxels", "input grid of voxel objects generated by Dots", GH_ParamAccess.list);
            // 1. input vertex
            pManager.AddIntegerParameter("start voxel(indices)", "start", "starting point given by index-list example: [0,0,0]", GH_ParamAccess.list, input);
            // 2. output vertex
            pManager.AddIntegerParameter("end voxel(indices)", "end", "end point given by index-list example: [3,1,2]", GH_ParamAccess.list, output);
        }

        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            // 0. debug string
            pManager.AddTextParameter("debug", "debug", "debug-ignore this field", GH_ParamAccess.list);
            // 1. straight line between points
            pManager.AddCurveParameter("straight-line-segment", "seg", "draws the straight line between the input and output points", GH_ParamAccess.item);
        }
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<string> s = new List<string>();

            List<Voxel> voxelLi = new List<Voxel>();
            List<int> inputIndex = new List<int>();
            List<int> outputIndex = new List<int>();
            if (!DA.GetDataList(0, voxelLi)) return;
            if (!DA.GetDataList(1, inputIndex)) return;
            if (!DA.GetDataList(2, outputIndex)) return;

            Point3d P = new Point3d();
            for(int i=0; i<voxelLi.Count; i++)
            {
                Voxel v = voxelLi[i];
                List<int> I = v.getIndexAsList();
                Point3d p = v.CenterPoint;
                bool t = idxMatch(I,inputIndex);
                if (t) P = p;
            }
            
            Point3d Q = new Point3d();
            for (int i = 0; i < voxelLi.Count; i++)
            {
                Voxel v = voxelLi[i];
                List<int> I = v.getIndexAsList();
                Point3d p = v.CenterPoint;
                bool t = idxMatch(I, outputIndex);
                if (t) Q = p;
            }

            try
            {
                LineCurve L = new LineCurve(P, Q);
                DA.SetData(1, L);
            }
            catch (Exception)
            {
                s.Add("Error in inputs");
            }

            s.Add("test1");
            s.Add("test2");
            DA.SetDataList(0, s);
        }
       protected override System.Drawing.Bitmap Icon
        {
            get
            {
                  return null;
            }
        }

        public bool idxMatch(List<int>I, List<int> J)
        {
            bool t = false;
            int p = I[0];
            int q = I[1];
            int r = I[2];
            int a = J[0];
            int b = J[1];
            int c = J[2];
            if (p == a && q == b && r == c)
            {
                t = true;
            }
            return t;
        }

        public override Guid ComponentGuid
        {
            get { return new Guid("59811ea6-fded-45c2-960b-f04ebb762073"); } // updated
        }
    }
}